---
title: "Overview to curatedPCaData"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: false
vignette: >
  %\VignetteIndexEntry{Overview to curatedPCaData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  tidy = TRUE,
  width.cutoff = 70
)

# Silently load the material
library(curatedPCaData)

###
#
# Create overview tables
#
###

# List of MAE objects
maes <- grep("mae_", utils::data(package="curatedPCaData")$result[,"Item"], value=TRUE)

# Currently used .csv template for clinical features to extract in all datasets (not possible but the ideal aim)
# Updated to be public exported for ease of use for authors and end-users
template <- template_prad
# Only loop through the optional fields
fields <- template[which(template$requiredness=="optional" & !template$col.name=="alt_sample_name"),"col.name"]

# Create a template matrix for data per study
mat <- matrix(NA, nrow=length(fields), ncol=2)
colnames(mat) <- c("Instances", "Missingness")
rownames(mat) <- fields

# Create functions for summarizing MAE-object fields
summarize_feature <- function(mae, feature){
	x <- MultiAssayExperiment::colData(mae)[,feature]
	# Summarizing character-fields
	if(all(is.na(x))){
		"N/A"
	}
	else if(template[which(template$col.name == feature),"var.class"] %in% c("character", "string")){
		# Tabulate and order tabulation
		tab <- table(x, useNA="ifany")
		tab <- sort(tab, decreasing=TRUE)
		# If there are only 3 or less unique character string entries summarize them
		if(length(unique(x))<=3){
			return(paste0(paste0(paste0(names(tab), ": ", tab), " (", round(tab/sum(tab)*100,0), "%)"), collapse=";"))
		}
		# Else summarize top 3 common entries and NAs
		else{
			return(paste0(paste0(paste0(paste0(names(tab)[1:3], ": ", tab[1:3]), " (", round(tab[1:3]/sum(tab)*100,0), "%)"), collapse=";"), "; ..."))
		}		
	# Summarizing numeric fields
	}else if(template[which(template$col.name == feature),"var.class"] %in% c("integer", "numeric")){
		# Cast to numeric; for example, an error entry may be psa value ">2000" causing string value
		x <- as.numeric(x)
		# If there are only 3 or less unique numeric entries summarize them tabulated
		if(length(unique(x))<=3){
			# Tabulate and order tabulation
			tab <- table(x, useNA="ifany")
			tab <- sort(tab, decreasing=TRUE)
			return(paste0(paste0(paste0(names(tab), ": ", tab), " (", round(tab/sum(tab)*100,0), "%)"), collapse=";"))
		}
		# For 4 or more unique values, use quantiles
		else{
			# Contains missing values
			if(any(is.na(x))){
				return(paste0("[",paste0(round(quantile(x, na.rm=TRUE),2), collapse=","),"], NA n=", sum(is.na(x))))
			# No missing values
			}else{ 
				return(paste0("[",paste0(round(quantile(x),2), collapse=", "),"]"))
			}
		}		
	}
	else{
		return("Unidentified var.class")
	}
}
missingness_feature <- function(mae, feature){
	x <- MultiAssayExperiment::colData(mae)[,feature]
	if(sum(is.na(x))>0){
		paste0("n=", sum(is.na(x)), " (", round(100*sum(is.na(x))/length(x),0), "%)")
	}
	else{
		"-"
	}
}

###
#
# Gleason grading tables
#
###

# Create a Gleason grade end-point availability table; NA-value in addition to Gleason sums of 5-10; Other-values for debugging
gleasons <- matrix(NA, nrow=length(maes), ncol=length(5:10)+1+1)
rownames(gleasons) <- paste(gsub("mae_", "", maes))
colnames(gleasons) <- c(5:10, "Other", "N/A")
for(i in 1:nrow(gleasons)){
	eval(parse(text=paste0("gl <- MultiAssayExperiment::colData(curatedPCaData::", maes[i], ")$gleason_grade")))
	# Iterate through gleasons 5-10
	gls <- 5:10
	for(j in 1:(ncol(gleasons)-2)){
		if(!sum(gl==gls[j], na.rm=TRUE)==0){
			gleasons[i,j] <- paste0(sum(gl==gls[j], na.rm=TRUE), " (", round(100*sum(gl==gls[j], na.rm=TRUE)/length(gl),0), "%)")	
		}else{
			gleasons[i,j] <- "-"
		}
	}
	# Other values
	vals <- c(5:10, NA, NA_real_)
	gleasons[i,ncol(gleasons)-1] <- paste0(sum(!gl %in% vals, na.rm=TRUE), " (", round(100*sum(!gl %in% vals, na.rm=TRUE)/length(gl),0), "%)")
	# NA-values
	gleasons[i,ncol(gleasons)] <- paste0(sum(is.na(gl), na.rm=TRUE), " (", round(100*sum(is.na(gl), na.rm=TRUE)/length(gl),0), "%)")
}

# Create a Grade group table; NA-value in addition to groups of <=6, 3+4, 4+3, 7 (if major+minor not separated), >=8, ; Other-values for debugging
groups <- matrix(NA, nrow=length(maes), ncol=5+1+1)
rownames(groups) <- paste(gsub("mae_", "", maes))
colnames(groups) <- c("<=6", "3+4", "4+3", "7", ">=8", "Other", "N/A")
for(i in 1:nrow(groups)){
	eval(parse(text=paste0("gr <- MultiAssayExperiment::colData(curatedPCaData::", maes[i], ")$grade_group")))
	# Iterate through Grade groups 
	grs <- c("<=6", "3+4", "4+3", "7", ">=8")
	for(j in 1:(ncol(groups)-2)){
		if(!sum(gr==grs[j], na.rm=TRUE)==0){
			groups[i,j] <- paste0(sum(gr==grs[j], na.rm=TRUE), " (", round(100*sum(gr==grs[j], na.rm=TRUE)/length(gr),0), "%)")	
		}else{
			groups[i,j] <- "-"
		}
	}
	# Other values
	vals <- c(grs, NA_character_, NA)
	groups[i,ncol(groups)-1] <- paste0(sum(!gr %in% vals, na.rm=TRUE), " (", round(100*sum(!gr %in% vals, na.rm=TRUE)/length(gr),0), "%)")
	# NA-values
	groups[i,ncol(groups)] <- paste0(sum(is.na(gr), na.rm=TRUE), " (", round(100*sum(is.na(gr), na.rm=TRUE)/length(gr),0), "%)")
}


###
#
# Survival/recurrence quantiles
#
###

survivals <- matrix(NA, nrow=length(maes), ncol=5)
rownames(survivals) <- paste(gsub("mae_", "", maes))
colnames(survivals) <- c("0 (no event)", "1 (event)", "N/A (event)", "Time (d)", "N/A (time)")
for(i in 1:nrow(survivals)){
	eval(parse(text=paste0("surv_time <- MultiAssayExperiment::colData(curatedPCaData::", maes[i], ")$days_to_overall_survival")))
	eval(parse(text=paste0("surv_event <- MultiAssayExperiment::colData(curatedPCaData::", maes[i], ")$overall_survival_status")))
	ifelse(all(is.na(surv_event)),
		survivals[i,1] <- "-",
		survivals[i,1] <- paste0(sum(surv_event == 0, na.rm=TRUE), " (", round(100*sum(surv_event == 0, na.rm=TRUE)/length(surv_event),0), "%)")
	)
	ifelse(all(is.na(surv_event)),
		survivals[i,2] <- "-",
		survivals[i,2] <- paste0(sum(surv_event == 1, na.rm=TRUE), " (", round(100*sum(surv_event == 1, na.rm=TRUE)/length(surv_event),0), "%)")
	)
	survivals[i,3] <- paste0(sum(is.na(surv_event)), " (", round(100*sum(is.na(surv_event))/length(surv_event),0), "%)")
	qs <- round(quantile(surv_time, na.rm=TRUE),0)
	ifelse(all(is.na(qs)),
		survivals[i,4] <- "-",
		survivals[i,4] <- paste0("[", qs[1], ",", qs[2], ",", qs[3], ",", qs[4], ",", qs[5], "]")
	)
	survivals[i,5] <- paste0(sum(is.na(surv_time)), " (", round(100*sum(is.na(surv_time))/length(surv_time),0), "%)")
}

recurrences <- matrix(NA, nrow=length(maes), ncol=5)
rownames(recurrences) <- paste(gsub("mae_", "", maes))
colnames(recurrences) <- c("0 (no event)", "1 (event)", "N/A (event)", "Time (d)", "N/A (time)")
for(i in 1:nrow(recurrences)){
	eval(parse(text=paste0("recur_time <- MultiAssayExperiment::colData(curatedPCaData::", maes[i], ")$days_to_disease_specific_recurrence")))
	eval(parse(text=paste0("recur_event <- MultiAssayExperiment::colData(curatedPCaData::", maes[i], ")$disease_specific_recurrence_status")))
	ifelse(all(is.na(recur_event)),
		recurrences[i,1] <- "-",
		recurrences[i,1] <- paste0(sum(recur_event == 0, na.rm=TRUE), " (", round(100*sum(recur_event == 0, na.rm=TRUE)/length(recur_event),0), "%)")
	)
	ifelse(all(is.na(recur_event)),
		recurrences[i,2] <- "-",
		recurrences[i,2] <- paste0(sum(recur_event == 1, na.rm=TRUE), " (", round(100*sum(recur_event == 1, na.rm=TRUE)/length(recur_event),0), "%)")
	)
	recurrences[i,3] <- paste0(sum(is.na(recur_event)), " (", round(100*sum(is.na(recur_event))/length(recur_event),0), "%)")
	qs <- round(quantile(recur_time, na.rm=TRUE),0)
	ifelse(all(is.na(qs)),
		recurrences[i,4] <- "-",
		recurrences[i,4] <- paste0("[", qs[1], ",", qs[2], ",", qs[3], ",", qs[4], ",", qs[5], "]")
	)
	recurrences[i,5] <- paste0(sum(is.na(recur_time)), " (", round(100*sum(is.na(recur_time))/length(recur_time),0), "%)")

}


###
#
# 'omics slot name and N counts in each MAE object
#
###

# Extract up-to-date slotnames over all MAE-objects
slotnames <- c()
for(mae in maes){
	eval(parse(text=paste0("mae_obj <- curatedPCaData::", mae)))
	slotnames <- c(slotnames, names(mae_obj))
}
# Unique slot names
slotnames <- unique(slotnames)
# Remove osf_* as a special case in TCGA; most likely to be separated as its own dataset
if(length(grep("osf", slotnames))>0) slotnames <- slotnames[-grep("osf", slotnames)]
# Create n count or absent (NA) matrix to be printed out
slotmat <- matrix("", nrow=length(slotnames), ncol=length(maes))
# Create a list of lists for sample names in different omics
sampnames <- list()
rownames(slotmat) <- sort(slotnames) # Alphabetic ordering
colnames(slotmat) <- maes
for(col in 1:length(maes)){
	sampnames[[length(sampnames)+1]] <- list()
	eval(parse(text=paste0("mae_obj <- curatedPCaData::", maes[col])))
	for(row in 1:nrow(slotmat)){
		if(rownames(slotmat)[row] %in% names(mae_obj)){
			slotmat[row,col] <- length(colnames(mae_obj[[rownames(slotmat)[row]]]))
			sampnames[[length(sampnames)]][[length(sampnames[[length(sampnames)]])+1]] <- colnames(mae_obj[[rownames(slotmat)[row]]])
			names(sampnames[[length(sampnames)]])[length(sampnames[[length(sampnames)]])] <- rownames(slotmat)[row]
		}
	}
}

# Give MAE names
names(sampnames) <- maes

# Transpose for more user-friendly printing in rmarkdown
slotmat <- t(slotmat)

# Which MAEs had 2 or more omics
multiomics <- names(which(unlist(lapply(sampnames, FUN=function(x) { length(names(x))>1 }))))
# Create an overlap N count matrix for GEX & CNA, CNA & MUT, GEX & CNA & MUT based on sample names
overmat <- matrix("", ncol=7, nrow=length(multiomics))
colnames(overmat) <- c("GEX", "CNA", "MUT", "GEX & CNA", "GEX & MUT", "CNA & MUT", "GEX & CNA & MUT")
rownames(overmat) <- multiomics

for(mult in multiomics){
	samps <- sampnames[[mult]]
	gex <- samps[[grep("gex", names(samps))[1]]]
	cna <- samps[[grep("cna", names(samps))[1]]]
	mut <- samps[[grep("mut", names(samps))[1]]]
	gex_cna <- length(intersect(gex, cna))
	gex_mut <- length(intersect(gex, mut))
	cna_mut <- length(intersect(cna, mut))
	gex_cna_mut <- length(intersect(intersect(gex, cna), mut))
	overmat[mult,] <- c(length(gex), length(cna), length(mut), gex_cna, gex_mut, cna_mut, gex_cna_mut)
}


```
# Package overview

This vignette introduces `curatedPCaData` and provides an overview for the package and the various datasets and the corresponding raw and processed data there-in. This overview provides insight into the available datasets (R package version ```utils::packageVersion("curatedPCaData")```) and provides basic example analyses there-in. 

***

3 different omics data types and accompanying clinical/phenotype data are currently available (stored in `/data-raw/` and not exported by the package namespace): 

1. `gex_*.RData` contains gene expression values
2. `cna_*.RData` contains copy number values
3. `mut_*.RData` contains somatic mutation calls
4. `clinical_*.RData` contains clinical/phenotype information
    
These data files have been processed and built into the `MultiAssayExperiment`-objects; however, if the user wishes to return and inspect the raw data files, the repositories still contain these files. 

These elements are created with internal functions within `curatedPCaData` and are then used to derive additional measures, such as immune deconvolution results and risk scores. 

Not all datasets will contain each of these elements but at minimum will contain `clinical_*.rda` and either `gex_*.rda` or `cna_*.rda`.
These individual elements are combined into a `MultiAssayExperiment object` (abbreviation: `MAE`, in lower case by convention) called `mae_*.rda` [Ramos et al., 2017]. These `MAE` objects are then exported by `curatedPCaData`.

For a comprehensive guide on how to neatly handle such `MAE` objects, refer to the MutliAssayExperiment user guide (or cheat-sheets): [MAE User Guide](https://www.bioconductor.org/packages/devel/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment.html) .

# R-package

The `curatedPCaData` package contains a collection of manually curated datasets concerning patients diagnosed with prostate cancer. The datasets within this package have followed uniform processing and naming conventions to allow users to more easily reproduce similar analyses between datasets and spend less time concerned with harmonzing data from different resources. 

# Importing data

The individual elements are housed within the `data-raw/` folder of the package [github repo](https://github.com/Syksy/curatedPCaData) and follows a simple naming convention of `data type` and `first author` separated by a `_` (see dataset types above). 
Each individual element for creating the final `MAE` were created using internal functions (accessible with `:::`).
A `MAE` for each study is provided to the users. 

To get a full list of available datasets use the `data` function (i.e. ```data(package="curatedPCaData")```):
```{r importing, results = 'asis', echo=FALSE}
library(curatedPCaData)
dats <- data(package="curatedPCaData")$results[,3:4]
dats <- dats[grep("mae_", dats[,1]),]
knitr::kable(dats, caption="List of datasets in curatedPCaData")
```

Individual datasets can also be imported by using the `data` function (see also `?loadPCa` for loading all MAE-objects):

```{r data-import}
data("mae_tcga")
mae_tcga
```

# Overview to the available datasets

## Datasets

The datasets were manually selected based on various criteria, such as:

- Primary data availability (preferably raw data available)
- Data platform types and their overlap (gene expression, copy number alteration, mutation data, ...)
- End points (e.g. recurrence, Gleason, ...)
- Clinical metadata availability and reliability
- Design of the study

### Studies

```{r studies, results = 'asis', echo=FALSE}

studies <- matrix("", nrow=nrow(dats), ncol=7)
colnames(studies) <- c("MAE-object", "Study short name(s)", "Sample types", "GEX/CNA/MUT platform(s)", "Notes", "Data source", "Reference(s)")
studies[,"MAE-object"] <- dats[,"Item"]
studies[,2] <- gsub(" MAE-object", "", dats[,2])
for(mae in studies[,"MAE-object"]){
	w <- which(mae == studies[,"MAE-object"])
	eval(parse(text=paste0("mae_obj <- curatedPCaData::", mae)))	
	samptypes <- table(colData(mae_obj)$sample_type)
	sampnames <- names(samptypes)
	studies[w,"Sample types"] <- paste(paste(sampnames, samptypes, sep=": "), collapse=", ")
	# Annotate additional useful information and append to correct positions
	if(mae == "mae_abida"){
		studies[w,"Data source"] <- "cBioPortal"
	}else if(mae == "mae_baca"){
		studies[w,"Data source"] <- "cBioPortal"
	}else if(mae == "mae_barbieri"){
		studies[w,"Data source"] <- "cBioPortal"
	}else if(mae == "mae_barwick"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "Custom DASL"
	}else if(mae == "mae_chandran"){
		studies[w,"Data source"] <- "GEO"	
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL8300 [HG_U95Av2]"
	}else if(mae == "mae_friedrich"){
		studies[w,"Data source"] <- "GEO"	
		studies[w,"GEX/CNA/MUT platform(s)"] <- "Custom Agilent array"
	}else if(mae == "mae_hieronymus"){
		studies[w,"Data source"] <- "GEO"	
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL8737 Agilent-021529 Human CGH"
		studies[w,"Notes"] <- "CNA only"
	}else if(mae == "mae_icgcca"){
		studies[w,"Data source"] <- "ICGC Data Portal (PRAD-CA)"	
		studies[w,"Notes"] <- "Canadian data from International Cancer Genome Collaboratory"
	}else if(mae == "mae_igc"){
		studies[w,"Data source"] <- "GEO"	
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL570 [HG-U133_Plus_2]"
	}else if(mae == "mae_kim"){
		studies[w,"Data source"] <- "GEO"	
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL5188 [HuEx-1_0-st]"
	}else if(mae == "mae_kunderfranco"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL887 Agilent-012097 Human 1A Microarray (V2)"		
	}else if(mae == "mae_ren"){
		studies[w,"Data source"] <- "cBioPortal"
	}else if(mae == "mae_sun"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL96 [HG-U133A]"		
	}else if(mae == "mae_taylor"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"Notes"] <- "Also known as MSKCC"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GEX: GPL5188 [HuEx-1_0-st], CNA: GPL4091 Agilent CGH"		
	}else if(mae == "mae_tcga"){
		studies[w,"Data source"] <- "Xenabrowser"
	}else if(mae == "mae_true"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL3834 FHCRC Human Prostate PEDB cDNA v3 / v4"		
	}else if(mae == "mae_wallace"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL571 [HG-U133A_2]"
	}else if(mae == "mae_wang"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL96 [HG-U133A]"	
	}else if(mae == "mae_weiner"){
		studies[w,"Data source"] <- "GEO"
		studies[w,"GEX/CNA/MUT platform(s)"] <- "GPL5175 [HuEx-1_0-st]"	
	}

}
knitr::kable(studies, caption="Key study characteristics")
```

### Curated clinical variables

The ```curatedPCaData```-package has been curated with an emphasis on the following primary clinical metadata, which were extracted and cleaned up always when available:

```{r template_prad, results='asis', echo=FALSE}
template <- curatedPCaData::template_prad
# Add spaces to |-dividers for linechanges
template <- do.call("cbind", lapply(template, FUN=function(x) { gsub("|", " | ", x, fixed=TRUE) }))
knitr::kable(template, caption="Template for Prostate Adecarcinoma clinical metadata")
```

### Clinical end-points

Three primary clinical end-points were utilized and are offered in colData-slots in the MAE-objects, if available:

* Gleason grade/Grade group(s)
* Biochemical Recurrence (BCR)
* Overall Survival (OS)

Below are summaries for each of these endpoints for each study. Of note, OS had very few events, thus survival modelling for this end-point may be considered unreliable.

```{r gleasons, results = 'asis', echo=FALSE}
knitr::kable(gleasons, caption="Gleason grades across datasets in curatedPCaData")
```

```{r groups, results = 'asis', echo=FALSE}
knitr::kable(groups, caption="Grade groups across datasets in curatedPCaData")
```

```{r recurrences, results = 'asis', echo=FALSE}
knitr::kable(recurrences, caption="Disease recurrence end point across datasets in curatedPCaData")
```

```{r os, results = 'asis', echo=FALSE}
knitr::kable(survivals, caption="Overall survival end point across datasets in curatedPCaData")
```

### Accessing primary data

The primary data types slots in the MAE objects for gene expression and copy number alteration will constist of two parts. Mutation data is provided as a ```RaggedExperiment``` object.

- Prefix indicating data type, either "gex_" or "cna_".
- Suffix indicating unit and processing for the data; for example, a gene expression dataset (gex) may have a suffix of "rma" for RMA-processed data, "FPKM" for processed RNA-seq data, "relz" for relative z-score normalized expression values for tumor-normal gene expression pairs, or "logq" for logarithmic quantile-normalized data. The main suffix for copy number alteration is the discretized GISTIC alteration calls with values {-2,-1,0,1,2}, although earlier version also provided log-ratios ("logr")
- Mutation data is provided as `RaggedExperiment` objects as "mut".

The standard way for accessing a data slot in MAE could be done for example via:

```{r access}
mae_taylor[["gex.rma"]][1:5,1:5]
```
The corresponding clinical variables have an accessor function ```colData``` provided by the ```MultiAssayExperiment```-package:

```{r clinical}
MultiAssayExperiment::colData(mae_tcga)[1:2,]
```

While it is ideal to make sure user is using the correct namespaces, the `pckgName::` can be omitted as `curatedPCaData` imports necessary packages such as `MultiAssayExperiment` and their functions should be available in the workspace.

## Omics sample count and overlap

The sample counts in each 'omics separately is listed below:

```{r samplecounts, results='asis', echo=FALSE}
knitr::kable(slotmat, caption="Sample N counts in each omics for every MAE object")
```

However, taking intersections between different omics shows that different samples were analyzed on different platforms - therefore the effective N counts for analyzing multiple 'omics platforms simultaneously is smaller. The overlaps between gene expression (GEX), copy number alteration (CNA), and mutations (MUT) are shown below:

```{r overlap, results='asis', echo=FALSE}
knitr::kable(overmat, caption="Sample N counts for intersections between different omics")
```

# Derived variables

In `curatedPCaData` we refer to derived variables as further downstream variables, which have been computed based on primarily data. For most cases, this was done by extracting key gene information from the `gex_*` slots and pre-computing informative downstream markers as described in their primary publications.

## Immune deconvolution

Tumor progression depends on the immune cell composition in the tumor microenvironment. The '[immunedeconv](https://github.com/icbi-lab/immunedeconv)' package consists of different computational methods to computationally estimate immune cell content using gene expression data. In addition, CIBERTSORTx is provided externally, as this method required registered access. For user convenience, it has been run separately and provided as a slot in the MAE objects. The other methods have been run using the ```immunedeconv``` package [Sturm et al., 2019] and code for reproducing these derived variables are provided alongside the package.

In this package, we provide estimates of immune cell content from the following deconvolution methods:

- quantiseq
- xcell
- epic
- mcp (counter)
- cibersort(x)

The estimates from each of these methods are stored in the MAE object as a seperate assay as shown for example in the Taylor dataset
```{r}
mae_taylor
```

To access the quantiseq results for the Taylor et. al dataset, these pre-computed values can be obtained from the corresponding slot in the MAE-object:
```{r}
head(mae_taylor[["cibersort"]])[1:5,1:3]
```

Similarly to access results from the other immune deconvolution methods, the following slots are available:
```{r}
head(mae_taylor[["quantiseq"]])[1:5,1:3]
head(mae_taylor[["xcell"]])[1:5,1:3]
head(mae_taylor[["epic"]])[1:5,1:3]
head(mae_taylor[["mcp"]])[1:5,1:3]
```

Each row of the deconvolution matrix represents the content of a certain immune cell type and the columns represent the patient sample IDs. The variables on the rows are specific for each method. Further, it should be noted that not all methods could be run on all datasets due to lack of overlap in genes of interest.

## Risk scores and other metrics

The slot ```scores``` is used to provide key risk scores or other informative metrics based on the primary data. These scores can be accessed as a matrix as if they were variables on an assay with this name:

```{r scores}
mae_tcga[["scores"]][,1:4]
```

The following PCa risk scores are offered:

- Decipher ```(rowname: decipher)``` [Herlemann et al., 2020]
- Oncotype DX ```(rowname: oncotype)``` [Knezevic et al., 2013]
- Prolaris ```(rowname: prolaris)``` [NICE Advice, 2018]

Further, the 20-gene Androgen Receptor (AR) score is calculated as described in the TCGA's Cell 2015 paper:

- AR score ```(rowname: ar_score)``` [Cancer Genome Atlas Research Network, 2015]

# Citations

- Ramos, M., Schiffer, L., Re, A., Azhar, R., Basunia, A., Rodriguez, C., Chan, T., Chapman, P., Davis, S. R., Gomez-Cabrero, D., Culhane, A. C., Haibe-Kains, B., Hansen, K. D., Kodali, H., Louis, M. S., Mer, A. S., Riester, M., Morgan, M., Carey, V., & Waldron, L. (2017). Software for the Integration of Multiomics Experiments in Bioconductor. Cancer research, 77(21), e39–e42. https://doi.org/10.1158/0008-5472.CAN-17-0344
- Sturm, G., Finotello, F., Petitprez, F., Zhang, J. D., Baumbach, J., Fridman, W. H., List, M., & Aneichyk, T. (2019). Comprehensive evaluation of transcriptome-based cell-type quantification methods for immuno-oncology. Bioinformatics (Oxford, England), 35(14), i436–i445. https://doi.org/10.1093/bioinformatics/btz363
- Cancer Genome Atlas Research Network (2015). The Molecular Taxonomy of Primary Prostate Cancer. Cell, 163(4), 1011–1025. https://doi.org/10.1016/j.cell.2015.10.025
- Wang, Z., Cao, S., Morris, J. S., Ahn, J., Liu, R., Tyekucheva, S., Gao, F., Li, B., Lu, W., Tang, X., Wistuba, I. I., Bowden, M., Mucci, L., Loda, M., Parmigiani, G., Holmes, C. C., & Wang, W. (2018). Transcriptome Deconvolution of Heterogeneous Tumor Samples with Immune Infiltration. iScience, 9, 451–460. https://doi.org/10.1016/j.isci.2018.10.028
- Herlemann, A., Huang, H. C., Alam, R., Tosoian, J. J., Kim, H. L., Klein, E. A., Simko, J. P., Chan, J. M., Lane, B. R., Davis, J. W., Davicioni, E., Feng, F. Y., McCue, P., Kim, H., Den, R. B., Bismar, T. A., Carroll, P. R., & Cooperberg, M. R. (2020). Decipher identifies men with otherwise clinically favorable-intermediate risk disease who may not be good candidates for active surveillance. Prostate cancer and prostatic diseases, 23(1), 136–143. https://doi.org/10.1038/s41391-019-0167-9
- Knezevic, D., Goddard, A. D., Natraj, N., Cherbavaz, D. B., Clark-Langone, K. M., Snable, J., Watson, D., Falzarano, S. M., Magi-Galluzzi, C., Klein, E. A., & Quale, C. (2013). Analytical validation of the Oncotype DX prostate cancer assay - a clinical RT-PCR assay optimized for prostate needle biopsies. BMC genomics, 14, 690. https://doi.org/10.1186/1471-2164-14-690
- NICE Advice - Prolaris gene expression assay for assessing long-term risk of prostate cancer progression: (C) NICE (2016) Prolaris gene expression assay for assessing long-term risk of prostate cancer progression. (2018). BJU international, 122(2), 173–180. https://doi.org/10.1111/bju.14452

# Session info

```{r session}
sessionInfo()
```

