---
title: "Overview to curatedPCaData"
output: 
  BiocStyle::html_document
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Overview to curatedPCaData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  tidy = TRUE,
  width.cutoff = 80
)

library(curatedPCaData)
# Iterate over the available datasets and make them available in vignette space for the latest time stamp
mae_abida <- curatedPCaData::getPCa("abida")
mae_baca <- curatedPCaData::getPCa("baca")
mae_barbieri <- curatedPCaData::getPCa("barbieri")
mae_barwick <- curatedPCaData::getPCa("barwick")
mae_chandran <- curatedPCaData::getPCa("chandran")
mae_friedrich <- curatedPCaData::getPCa("friedrich")
mae_hieronymus <- curatedPCaData::getPCa("hieronymus")
mae_icgcca <- curatedPCaData::getPCa("icgcca")
mae_igc <- curatedPCaData::getPCa("igc")
mae_kim <- curatedPCaData::getPCa("kim")
mae_kunderfranco <- curatedPCaData::getPCa("kunderfranco")
mae_ren <- curatedPCaData::getPCa("ren")
mae_sun <- curatedPCaData::getPCa("sun")
mae_taylor <- curatedPCaData::getPCa("taylor")
mae_tcga <- curatedPCaData::getPCa("tcga")
mae_true <- curatedPCaData::getPCa("true")
mae_wallace <- curatedPCaData::getPCa("wallace")
mae_wang <- curatedPCaData::getPCa("wang")
mae_weiner <- curatedPCaData::getPCa("weiner")

###
#
# Create overview tables
#
###

# List of MAE objects
maes <- grep("mae_", ls(), value = TRUE)

# Clinical metadata template
data(template_prad)
template <- template_prad
# Only loop through the optional fields
fields <- template[which(template$requiredness == "optional" & !template$col.name == "alt_sample_name"), "col.name"]

# Create a template matrix for data per study
mat <- matrix(NA, nrow = length(fields), ncol = 2)
colnames(mat) <- c("Instances", "Missingness")
rownames(mat) <- fields

# Create functions for summarizing MAE-object fields
summarize_feature <- function(mae, feature) {
  x <- MultiAssayExperiment::colData(mae)[, feature]
  # Summarizing character-fields
  if (all(is.na(x))) {
    "N/A"
  } else if (template[which(template$col.name == feature), "var.class"] %in% c("character", "string")) {
    # Tabulate and order tabulation
    tab <- table(x, useNA = "ifany")
    tab <- sort(tab, decreasing = TRUE)
    # If there are only 3 or less unique character string entries summarize them
    if (length(unique(x)) <= 3) {
      return(paste0(paste0(paste0(names(tab), ": ", tab), " (", round(tab / sum(tab) * 100, 0), "%)"), collapse = ";"))
    }
    # Else summarize top 3 common entries and NAs
    else {
      return(paste0(paste0(paste0(paste0(names(tab)[1:3], ": ", tab[1:3]), " (", round(tab[1:3] / sum(tab) * 100, 0), "%)"), collapse = ";"), "; ..."))
    }
    # Summarizing numeric fields
  } else if (template[which(template$col.name == feature), "var.class"] %in% c("integer", "numeric")) {
    # Cast to numeric; for example, an error entry may be psa value ">2000" causing string value
    x <- as.numeric(x)
    # If there are only 3 or less unique numeric entries summarize them tabulated
    if (length(unique(x)) <= 3) {
      # Tabulate and order tabulation
      tab <- table(x, useNA = "ifany")
      tab <- sort(tab, decreasing = TRUE)
      return(paste0(paste0(paste0(names(tab), ": ", tab), " (", round(tab / sum(tab) * 100, 0), "%)"), collapse = ";"))
    }
    # For 4 or more unique values, use quantiles
    else {
      # Contains missing values
      if (any(is.na(x))) {
        return(paste0("[", paste0(round(quantile(x, na.rm = TRUE), 2), collapse = ","), "], NA n=", sum(is.na(x))))
        # No missing values
      } else {
        return(paste0("[", paste0(round(quantile(x), 2), collapse = ", "), "]"))
      }
    }
  } else {
    return("Unidentified var.class")
  }
}
missingness_feature <- function(mae, feature) {
  x <- MultiAssayExperiment::colData(mae)[, feature]
  if (sum(is.na(x)) > 0) {
    paste0("n=", sum(is.na(x)), " (", round(100 * sum(is.na(x)) / length(x), 0), "%)")
  } else {
    "-"
  }
}

###
#
# Gleason grading tables
#
###

# Create a Gleason grade end-point availability table; NA-value in addition to Gleason sums of 5-10; Other-values for debugging
gleasons <- matrix(NA, nrow = length(maes), ncol = length(5:10) + 1 + 1)
rownames(gleasons) <- paste(gsub("mae_", "", maes))
colnames(gleasons) <- c(5:10, "Other", "N/A")
for (i in 1:nrow(gleasons)) {
  eval(parse(text = paste0("gl <- MultiAssayExperiment::colData(", maes[i], ")$gleason_grade")))
  # Iterate through gleasons 5-10
  gls <- 5:10
  for (j in 1:(ncol(gleasons) - 2)) {
    if (!sum(gl == gls[j], na.rm = TRUE) == 0) {
      gleasons[i, j] <- paste0(sum(gl == gls[j], na.rm = TRUE), " (", round(100 * sum(gl == gls[j], na.rm = TRUE) / length(gl), 0), "%)")
    } else {
      gleasons[i, j] <- "-"
    }
  }
  # Other values
  vals <- c(5:10, NA, NA_real_)
  gleasons[i, ncol(gleasons) - 1] <- paste0(sum(!gl %in% vals, na.rm = TRUE), " (", round(100 * sum(!gl %in% vals, na.rm = TRUE) / length(gl), 0), "%)")
  # NA-values
  gleasons[i, ncol(gleasons)] <- paste0(sum(is.na(gl), na.rm = TRUE), " (", round(100 * sum(is.na(gl), na.rm = TRUE) / length(gl), 0), "%)")
}

# Create a Grade group table; NA-value in addition to groups of <=6, 3+4, 4+3, 7 (if major+minor not separated), >=8, ; Other-values for debugging
groups <- matrix(NA, nrow = length(maes), ncol = 5 + 1 + 1)
rownames(groups) <- paste(gsub("mae_", "", maes))
colnames(groups) <- c("<=6", "3+4", "4+3", "7", ">=8", "Other", "N/A")
for (i in 1:nrow(groups)) {
  eval(parse(text = paste0("gr <- MultiAssayExperiment::colData(", maes[i], ")$grade_group")))
  # Iterate through Grade groups
  grs <- c("<=6", "3+4", "4+3", "7", ">=8")
  for (j in 1:(ncol(groups) - 2)) {
    if (!sum(gr == grs[j], na.rm = TRUE) == 0) {
      groups[i, j] <- paste0(sum(gr == grs[j], na.rm = TRUE), " (", round(100 * sum(gr == grs[j], na.rm = TRUE) / length(gr), 0), "%)")
    } else {
      groups[i, j] <- "-"
    }
  }
  # Other values
  vals <- c(grs, NA_character_, NA)
  groups[i, ncol(groups) - 1] <- paste0(sum(!gr %in% vals, na.rm = TRUE), " (", round(100 * sum(!gr %in% vals, na.rm = TRUE) / length(gr), 0), "%)")
  # NA-values
  groups[i, ncol(groups)] <- paste0(sum(is.na(gr), na.rm = TRUE), " (", round(100 * sum(is.na(gr), na.rm = TRUE) / length(gr), 0), "%)")
}


###
#
# Survival/recurrence quantiles
#
###

survivals <- matrix(NA, nrow = length(maes), ncol = 5)
rownames(survivals) <- paste(gsub("mae_", "", maes))
colnames(survivals) <- c("0 (no event)", "1 (event)", "N/A (event)", "Time (d)", "N/A (time)")
for (i in 1:nrow(survivals)) {
  eval(parse(text = paste0("surv_time <- MultiAssayExperiment::colData(", maes[i], ")$days_to_overall_survival")))
  eval(parse(text = paste0("surv_event <- MultiAssayExperiment::colData(", maes[i], ")$overall_survival_status")))
  ifelse(all(is.na(surv_event)),
    survivals[i, 1] <- "-",
    survivals[i, 1] <- paste0(sum(surv_event == 0, na.rm = TRUE), " (", round(100 * sum(surv_event == 0, na.rm = TRUE) / length(surv_event), 0), "%)")
  )
  ifelse(all(is.na(surv_event)),
    survivals[i, 2] <- "-",
    survivals[i, 2] <- paste0(sum(surv_event == 1, na.rm = TRUE), " (", round(100 * sum(surv_event == 1, na.rm = TRUE) / length(surv_event), 0), "%)")
  )
  survivals[i, 3] <- paste0(sum(is.na(surv_event)), " (", round(100 * sum(is.na(surv_event)) / length(surv_event), 0), "%)")
  qs <- round(quantile(surv_time, na.rm = TRUE), 0)
  ifelse(all(is.na(qs)),
    survivals[i, 4] <- "-",
    survivals[i, 4] <- paste0("[", qs[1], ",", qs[2], ",", qs[3], ",", qs[4], ",", qs[5], "]")
  )
  survivals[i, 5] <- paste0(sum(is.na(surv_time)), " (", round(100 * sum(is.na(surv_time)) / length(surv_time), 0), "%)")
}

recurrences <- matrix(NA, nrow = length(maes), ncol = 5)
rownames(recurrences) <- paste(gsub("mae_", "", maes))
colnames(recurrences) <- c("0 (no event)", "1 (event)", "N/A (event)", "Time (d)", "N/A (time)")
for (i in 1:nrow(recurrences)) {
  eval(parse(text = paste0("recur_time <- MultiAssayExperiment::colData(", maes[i], ")$days_to_disease_specific_recurrence")))
  eval(parse(text = paste0("recur_event <- MultiAssayExperiment::colData(", maes[i], ")$disease_specific_recurrence_status")))
  ifelse(all(is.na(recur_event)),
    recurrences[i, 1] <- "-",
    recurrences[i, 1] <- paste0(sum(recur_event == 0, na.rm = TRUE), " (", round(100 * sum(recur_event == 0, na.rm = TRUE) / length(recur_event), 0), "%)")
  )
  ifelse(all(is.na(recur_event)),
    recurrences[i, 2] <- "-",
    recurrences[i, 2] <- paste0(sum(recur_event == 1, na.rm = TRUE), " (", round(100 * sum(recur_event == 1, na.rm = TRUE) / length(recur_event), 0), "%)")
  )
  recurrences[i, 3] <- paste0(sum(is.na(recur_event)), " (", round(100 * sum(is.na(recur_event)) / length(recur_event), 0), "%)")
  qs <- round(quantile(recur_time, na.rm = TRUE), 0)
  ifelse(all(is.na(qs)),
    recurrences[i, 4] <- "-",
    recurrences[i, 4] <- paste0("[", qs[1], ",", qs[2], ",", qs[3], ",", qs[4], ",", qs[5], "]")
  )
  recurrences[i, 5] <- paste0(sum(is.na(recur_time)), " (", round(100 * sum(is.na(recur_time)) / length(recur_time), 0), "%)")
}


###
#
# 'omics slot name and N counts in each MAE object
#
###

# Extract up-to-date slotnames over all MAE-objects
slotnames <- c()
for (mae in maes) {
  eval(parse(text = paste0("maeobj <- ", mae)))
  slotnames <- c(slotnames, names(maeobj))
}
# Unique slot names
slotnames <- unique(slotnames)
# Create n count or absent (NA) matrix to be printed out
slotmat <- matrix("", nrow = length(slotnames), ncol = length(maes))
# Create a list of lists for sample names in different omics
sampnames <- list()
rownames(slotmat) <- sort(slotnames) # Alphabetic ordering
colnames(slotmat) <- maes
for (col in 1:length(maes)) {
  sampnames[[length(sampnames) + 1]] <- list()
  eval(parse(text = paste0("maeobj <- ", maes[col])))
  for (row in 1:nrow(slotmat)) {
    if (rownames(slotmat)[row] %in% names(maeobj)) {
      slotmat[row, col] <- length(colnames(maeobj[[rownames(slotmat)[row]]]))
      sampnames[[length(sampnames)]][[length(sampnames[[length(sampnames)]]) + 1]] <- colnames(maeobj[[rownames(slotmat)[row]]])
      names(sampnames[[length(sampnames)]])[length(sampnames[[length(sampnames)]])] <- rownames(slotmat)[row]
    }
  }
}

# Give MAE names
names(sampnames) <- maes

# Transpose for more user-friendly printing in rmarkdown
slotmat <- t(slotmat)

# Which MAEs had 2 or more omics
multiomics <- names(which(unlist(lapply(sampnames, FUN = function(x) {
  length(names(x)) > 1
}))))
# Create an overlap N count matrix for GEX & CNA, CNA & MUT, GEX & CNA & MUT based on sample names
overmat <- matrix("", ncol = 7, nrow = length(multiomics))
colnames(overmat) <- c("GEX", "CNA", "MUT", "GEX & CNA", "GEX & MUT", "CNA & MUT", "GEX & CNA & MUT")
rownames(overmat) <- multiomics

for (mult in multiomics) {
  samps <- sampnames[[mult]]
  gex <- samps[[grep("gex", names(samps))[1]]]
  cna <- samps[[grep("cna", names(samps))[1]]]
  mut <- samps[[grep("mut", names(samps))[1]]]
  gex_cna <- length(intersect(gex, cna))
  gex_mut <- length(intersect(gex, mut))
  cna_mut <- length(intersect(cna, mut))
  gex_cna_mut <- length(intersect(intersect(gex, cna), mut))
  overmat[mult, ] <- c(length(gex), length(cna), length(mut), gex_cna, gex_mut, cna_mut, gex_cna_mut)
}
```
# Package overview

This overview provides insight into the available datasets (R package version `r utils::packageVersion("curatedPCaData")`) provided via `ExperimentHub` cloud services. 
The main data class is a `MultiAssayExperiment` (MAE) object compatible with numerous Bioconductor packages.

***

3 different omics base data types and accompanying clinical/phenotype data are currently available: 

1. `gex.*` assays contain gene expression values, with the suffix wildcard indicating unit or method for gene expression
2. `cna.*` assays contain copy number values, with the suffix wildcard indicating method for copy number alterations
3. `mut` assays contain somatic mutation calls
4. `MultiAssayExperiment::colData(maeobj)` contains the clinical metadata curated based on a pre-defined template

Their availability is subject to the study in question, and you will find coverage of the omics here-in. Furthermore, derived variables based on these base data types are provided in the constructed `MultiAssayExperiment` (MAE) class objects.

For a comprehensive guide on how to neatly handle such `MAE` objects, refer to the MultiAssayExperiment user guide (or cheat-sheets): [MAE User Guide](https://www.bioconductor.org/packages/devel/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment.html) .

# R-package

The `curatedPCaData` package contains a collection of manually curated datasets concerning patients diagnosed with prostate cancer. The datasets within this package have followed uniform processing and naming conventions to allow users to more easily reproduce similar analyses between datasets and spend less time concerned with harmonzing data from different sources. 

# Downloading data from ExperimentHub or loading them from local cache

To get a full list of available datasets see the documentation for `getPCa` function, or via querying `ExperimentHub`directly for the components used to construct `MultiAssayExperiments` for the studies. However, `getPCa` is aimed to comprehensively provide readily usable multi-omics compatible MAE-objects.

# Overview to the available datasets

## Datasets

The datasets were manually selected based on various criteria, such as:

- Primary data availability (preferably raw data available)
- Data platform types and their overlap (gene expression, copy number alteration, mutation data, ...)
- End points (e.g. recurrence, Gleason, ...)
- Clinical metadata availability and reliability
- Design of the study

### Studies

The function `getPCa` utilizes the studies' short name for identifying which data to extract. An overview into the main datasets is as follows:

```{r studies, results = 'asis', echo=FALSE}
studies <- matrix("", nrow = length(maes), ncol = 7)
colnames(studies) <- c("MAE-object", "Study short name(s)", "Sample types", "GEX/CNA/MUT platform(s)", "Notes", "Data source", "Reference(s)")
studies[, "MAE-object"] <- grep("mae_", ls(), value = TRUE)
studies[, 2] <- gsub("mae_", "", studies[, "MAE-object"])
# Reformat names with special cases for abbreviations vs. names
studies[, 2] <- ifelse(studies[, 2] %in% c("tcga", "icgcca", "igc"), base::toupper(studies[, 2]), stringr::str_to_title(studies[, 2]))
for (mae in studies[, "MAE-object"]) {
  w <- which(mae == studies[, "MAE-object"])
  eval(parse(text = paste0("maeobj <- ", mae)))
  samptypes <- table(colData(maeobj)$sample_type)
  sampnames <- names(samptypes)
  studies[w, "Sample types"] <- paste(paste(sampnames, samptypes, sep = ": "), collapse = ", ")
  # Annotate additional useful information and append to correct positions
  if (mae == "mae_abida") {
    studies[w, "Data source"] <- "cBioPortal"
    studies[w, "Reference(s)"] <- "Abida et al."
  } else if (mae == "mae_baca") {
    studies[w, "Data source"] <- "cBioPortal"
    studies[w, "Reference(s)"] <- "Baca et al."
  } else if (mae == "mae_barbieri") {
    studies[w, "Data source"] <- "cBioPortal"
    studies[w, "Reference(s)"] <- "Barbieri et al."
  } else if (mae == "mae_barwick") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "Custom DASL"
    studies[w, "Reference(s)"] <- "Barwick et al."
  } else if (mae == "mae_chandran") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL8300 [HG_U95Av2]"
    studies[w, "Reference(s)"] <- "Chandran et al., Yu et al."
  } else if (mae == "mae_friedrich") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "Custom Agilent array"
    studies[w, "Reference(s)"] <- "Friedrich et al."
  } else if (mae == "mae_hieronymus") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL8737 Agilent-021529 Human CGH"
    studies[w, "Notes"] <- "CNA only"
    studies[w, "Reference(s)"] <- "Hieronymus et al."
  } else if (mae == "mae_icgcca") {
    studies[w, "Data source"] <- "ICGC Data Portal (PRAD-CA)"
    studies[w, "Notes"] <- "Canadian data from International Cancer Genome Collaboratory"
    studies[w, "Reference(s)"] <- "PRAD-CA in Zhang et al."
  } else if (mae == "mae_igc") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL570 [HG-U133_Plus_2]"
    studies[w, "Reference(s)"] <- "GEO accession code GSE2109"
  } else if (mae == "mae_kim") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL5188 [HuEx-1_0-st]"
    studies[w, "Reference(s)"] <- "Kim et al."
  } else if (mae == "mae_kunderfranco") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL887 Agilent-012097 Human 1A Microarray (V2)"
    studies[w, "Reference(s)"] <- "Kunderfranco et al., Peraldo-Neia et al., Longoni et al."
  } else if (mae == "mae_ren") {
    studies[w, "Data source"] <- "cBioPortal"
    studies[w, "Reference(s)"] <- "Ren et al."
  } else if (mae == "mae_sun") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL96 [HG-U133A]"
    studies[w, "Reference(s)"] <- "Sun et al."
  } else if (mae == "mae_taylor") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "Notes"] <- "Also known as MSKCC"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GEX: GPL5188 [HuEx-1_0-st], CNA: GPL4091 Agilent CGH"
    studies[w, "Reference(s)"] <- "Taylor et al."
  } else if (mae == "mae_tcga") {
    studies[w, "Data source"] <- "Xenabrowser"
    studies[w, "Reference(s)"] <- "Cancer Genome Atlas Research Network, Goldman et al."
  } else if (mae == "mae_true") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL3834 FHCRC Human Prostate PEDB cDNA v3 / v4"
    studies[w, "Reference(s)"] <- "True et al."
  } else if (mae == "mae_wallace") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL571 [HG-U133A_2]"
    studies[w, "Reference(s)"] <- "Wallace et al."
  } else if (mae == "mae_wang") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL96 [HG-U133A]"
    studies[w, "Reference(s)"] <- "Wang et al., Jia et al."
  } else if (mae == "mae_weiner") {
    studies[w, "Data source"] <- "GEO"
    studies[w, "GEX/CNA/MUT platform(s)"] <- "GPL5175 [HuEx-1_0-st]"
    studies[w, "Reference(s)"] <- "Weiner et al."
  }
}
knitr::kable(studies, caption = "Key study characteristics")
```

Please note that the TCGA PCa dataset is a subset of the TCGA pan-cancer initiative. For a package focused on TCGA exclusively beyond the PRAD subset, see the Bioconductor package [curatedTCGAData](https://bioconductor.org/packages/release/data/experiment/html/curatedTCGAData.html).

## Citations

The use of ```curatedPCaData``` ought to be cited with [@Laajala2023].

For individual datasets there-in, the following citations are suggested:

* Abida et al. : [@Abida2019]
* Baca et al. : [@Baca2013]
* Barbieri et al. : [@Barbieri2012]
* Barwick et al. : [@Barwick2010]
* Chandran et al. : [@Chandran2007]
* Friedrich et al. : [@Friedrich2020] 
* Hieronymus et al. : [@Hieronymus2014]
* ICGC (Canadian) : PRAD-CA in [@Zhang2019]
* IGC : GEO accession GSE2109
* Kim et al. : [@Kim2018]
* Kunderfranco et al. : [@Kunderfranco2010], [@PeraldoNeia2011], [@Longoni2012]
* Ren et al. : [@Ren2018]
* Sun et al. : [@Sun2009]
* Taylor et al. : [@Taylor2010]
* TCGA : [@TCGA2015], [@Goldman2020]
* True et al. : [@True2006]
* Wallace et al. : [@Wallace2008]
* Wang et al. : [@Wang2010], [@Jia2011]
* Weiner et al. : [@Weiner2021]

### Curated clinical variables

The ```curatedPCaData```-package has been curated with an emphasis on the following primary clinical metadata, which were extracted and cleaned up always when available:

```{r template_prad, results='asis', echo=FALSE}
data(template_prad)
template <- template_prad
# Add spaces to |-dividers for linechanges
template <- do.call("cbind", lapply(template, FUN = function(x) {
  gsub("|", " | ", x, fixed = TRUE)
}))
knitr::kable(template, caption = "Template for prostate adenocarcinoma clinical metadata")
```

### Clinical end-points

Three primary clinical end-points were utilized and are offered in the clinical metadata in colData for the MAE-objects, if available:

* Gleason grade/Grade group(s)
* Biochemical Recurrence (BCR)
* Overall Survival (OS)

Below are summaries for each of these endpoints for each study. Of note, OS had very few events, thus survival modelling for this end-point may be considered unreliable.

```{r gleasons, results = 'asis', echo=FALSE}
knitr::kable(gleasons, caption = "Gleason grades across datasets in curatedPCaData")
```

```{r groups, results = 'asis', echo=FALSE}
knitr::kable(groups, caption = "Grade groups across datasets in curatedPCaData")
```

```{r recurrences, results = 'asis', echo=FALSE}
knitr::kable(recurrences, caption = "Disease recurrence end point across datasets in curatedPCaData")
```

```{r os, results = 'asis', echo=FALSE}
knitr::kable(survivals, caption = "Overall survival end point across datasets in curatedPCaData")
```

### Querying datasets

The function ```getPCa``` functions as the primary interface with building MAE-objects from either live download from ```ExperimentHub``` or by loading them from local cache, if the datasets have been downloaded previously.

The syntax for the function ```getPCa(dataset, assays, timestamp, verbose, ...)``` consists of the following parameters:
* ```dataset```: Primary indicator for which study to query from ```ExperimentHub```; notice that this may only be one of the allowed values.
* ```assays```: This indicates which MAE-assays are fetched from the candidate ExperimentList. Two names are always required (and are filled if missing): ```colData``` which contains information on the clinical metadata, and ```sampleMap``` which maps the rownames of the metadata to columns in the fetched assay data. 
* ```timestamp```: When data is deposited in the ```ExperimentHub``` resources, they are time stamped to avoid ambiguity. The timestamps provided in this parameter are resolved from left to right, and the first deposit stamp is ```"20230215```. 
* ```verbose```: Logical indicator whether additional information should be printed by ```getPCa```.
* ```...```: Further custom parameters passed on to ```getPCa```.

As an example, let us consider querying the TCGA dataset, but suppose only wish to extract the gene expression data, and the immune deconvolution results derived by the method xCell. Further, we'll request risk and AR scores slot. This subset could be retrieved with:

```{r tcgaex}
tcga_subset <- getPCa(dataset = "tcga", assays = c("gex.rsem.log", "xcell", "scores"), timestamp = "20230215")

tcga_subset
``` 

The standard way of extracting the latest MAE-object with all available assays is done via querying with just the dataset name:

```{r ehquery}
mae_tcga <- getPCa("tcga")
mae_taylor <- getPCa("taylor")
```

### Accessing primary data

The primary assay names in the MAE objects for gene expression and copy number alteration will consist of two parts. Mutation data is provided as a ```RaggedExperiment``` object.

- Prefix indicating data type, either "gex." or "cna.".
- Suffix indicating unit and processing for the data; for example, a gene expression dataset (gex) may have a suffix of "rma" for RMA-processed data, "fpkm" for processed RNA-seq data, "relz" for relative z-score normalized expression values for tumor-normal gene expression pairs, or "logq" for logarithmic quantile-normalized data. The main suffix for copy number alteration is the discretized GISTIC alteration calls with values {-2,-1,0,1,2}, although earlier version also provided log-ratios ("logr")
- Mutation data is provided as `RaggedExperiment` objects as "mut".

The standard way for accessing a data slot in MAE could be done for example via:

```{r access}
mae_taylor[["gex.rma"]][1:5, 1:5]
```
The corresponding clinical variables have an accessor function ```colData``` provided by the ```MultiAssayExperiment```-package:

```{r clinical}
MultiAssayExperiment::colData(mae_tcga)[1:2, ]
```

While it is ideal to make sure user is using the correct namespaces, the `pckgName::` can be omitted as `curatedPCaData` imports necessary packages such as `MultiAssayExperiment` and their functions should be available in the workspace.

### ExperimentHub data listing

In order to access the latest listing of ```curatedPCaData``` related resources available in ```ExperimentHub```, consult the ```metadata.csv``` file delivered with the package:

```{r metadat}
metadata <- read.csv(system.file("extdata", "metadata.csv", package = "curatedPCaData"))
head(metadata)
```


## Omics sample count and overlap

The sample counts in each 'omics separately is listed below:

```{r samplecounts, results='asis', echo=FALSE}
knitr::kable(slotmat, caption = "Sample N counts in each omics for every MAE object")
```

However, taking intersections between different omics shows that different samples were analyzed on different platforms - therefore the effective N counts for analyzing multiple 'omics platforms simultaneously is smaller. The overlaps between gene expression (GEX), copy number alteration (CNA), and mutations (MUT) are shown below:

```{r overlap, results='asis', echo=FALSE}
knitr::kable(overmat, caption = "Sample N counts for intersections between different omics")
```

# Derived variables

In `curatedPCaData` we refer to derived variables as further downstream variables, which have been computed based on primarily data. For most cases, this was done by extracting key gene information from the `gex_*` assays and pre-computing informative downstream markers as described in their primary publications.

## Immune deconvolution

Tumor progression depends on the immune cell composition in the tumor microenvironment. The '[immunedeconv](https://github.com/icbi-lab/immunedeconv)' package consists of different computational methods to computationally estimate immune cell content using gene expression data. In addition, CIBERTSORTx is provided externally, as this method required registered access. For user convenience, it has been run separately and provided as a slot in the MAE objects. The other methods have been run using the ```immunedeconv``` package [@Sturm2019] and code for reproducing these derived variables are provided alongside the package.

In this package, we provide estimates of immune cell content from the following deconvolution methods:

- quanTIseq
- xCell
- EPIC
- MCP counter
- CIBERSORT(x)
- ESTIMATE

The estimates from each of these methods are stored in the MAE object as a seperate assay as shown for example in the Taylor dataset
```{r}
mae_taylor
```

To access the quantiseq results for the Taylor et. al dataset, these pre-computed values can be obtained from the corresponding slot in the MAE-object:
```{r}
head(mae_taylor[["cibersort"]])[1:5, 1:3]
```

Similarly to access results from the other immune deconvolution methods, the following assays/experiments are also available:
```{r}
head(mae_taylor[["quantiseq"]])[1:5, 1:3]
head(mae_taylor[["xcell"]])[1:5, 1:3]
head(mae_taylor[["epic"]])[1:5, 1:3]
head(mae_taylor[["mcp"]])[1:5, 1:3]
```

Each row of the deconvolution matrix represents the content of a certain immune cell type and the columns represent the patient sample IDs. The variables on the rows are specific for each method. Further, it should be noted that not all methods could be run on all datasets due to lack of overlap in genes of interest.

## Risk scores and other metrics

The slot ```scores``` is used to provide key risk scores or other informative metrics based on the primary data. These scores can be accessed as a matrix as if they were variables on an assay with this name:

```{r scores}
mae_tcga[["scores"]][, 1:4]
```

The following PCa risk scores are offered:

- Decipher ```(rowname: decipher)``` [@Herlemann2019]
- Oncotype DX ```(rowname: oncotype)``` [@Knezevic2013]
- Prolaris ```(rowname: prolaris)``` [@NICE2018]

Further, the 20-gene Androgen Receptor (AR) score is calculated as described in the TCGA's Cell 2015 paper:

- AR score ```(rowname: ar_score)``` [@TCGA2015]

# Session info

```{r session}
sessionInfo()
```

# References
